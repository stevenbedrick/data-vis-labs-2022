---
title: 'Lab 05: Fonts & Tables'
author: "Alison Hill & Steven Bedrick"
subtitle: "BMI 5/625"
always_allow_html: true
output:
  html_document:
    number_sections: yes
    theme: flatly
    toc: yes
    toc_depth: 2
    toc_float: yes
  # pdf_document:
    # toc: yes
    # toc_depth: '2'
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(error = TRUE, comment = NA, warning = FALSE, errors = FALSE, message = FALSE, tidy = FALSE, cache = FALSE)
```

# Goals for Lab 05

Become familiar with tools for generating publication-ready tables directly in R.

We will use data from the following paper: MacFarlane, H., Gorman, K., Ingham, R., Presmanes Hill, A., Papadakis, K., Kiss, G., & van Santen, J. (2017). [Quantitative analysis of disfluency in children with autism spectrum disorder or language impairment.](http://doi.org/10.1371/journal.pone.0173936) PLoS ONE, 12(3), e0173936. 

```{r load_packages, include = FALSE}
library(tidyverse)
library(janitor)
library(knitr)
library(DT)
library(xtable)
library(broom)
library(tableone)
library(formattable)
library(pnwflights14) # devtools::install_github("ismayc/pnwflights14")
library(pixiedust)
library(kableExtra)
library(huxtable)
```

```{r}
mazes <- read_csv("http://bit.ly/mazes-gist") %>% 
  clean_names()  #janitor package

glimpse(mazes)

```


# TL;DR

The workhorse for making tables in R Markdown documents is the `knitr` package's `kable` function. This function is really versatile, but also free of fancy formatting options, for better or worse.

# `knitr::kable`

## `kable` all tables everywhere

In order to tell RMarkdown to use `kable` to format all tabular output, update the YAML of your document. For HTML:

```{r eval = FALSE}
---
title: "My Awesome Data Vis Lab"
output:
  html_document:
    df_print: kable
---
```

You can also define the html format in the global options.
```{r eval = FALSE}
# If you don't define format here, you'll need put `format = "html"` in every kable function.
options(knitr.table.format = "html") 
# You may also wish to set this option
options(scipen = 1, digits = 2)
```


## `kable` table in a chunk

For HTML output:

```{r}
head(mazes) %>% 
  kable(format = "html")
```

Note that this is a bit rough-looking. We will use various features of `kable` to improve our output.

For starters, we can add a caption:

```{r}
head(mazes) %>% 
  kable(format = "html", digits = 2, caption = "A table produced by kable.")
```

We can also manually specify human-readable column names:

```{r}
my_maze_names <- c("Participant", "Age", "Verbal\nIQ", "Group", "Activity", "Content\nMaze", "Filler\nMaze", "Repetition", "Revision", "False\nStart", "Cued", "Not\nCued")
head(mazes) %>% 
  kable(format = "html", digits = 2, caption = "A table produced by kable.",
        col.names = my_maze_names)
```


## Styled `kable` tables in a chunk

To improve the visual layout of the table, we can use the `kableExtra` package, which provides the `kable_styling()` function:

```{r}
head(mazes) %>% 
  kable(format = "html", digits = 2, caption = "A styled kable table.",
        col.names = my_maze_names) %>% 
  kable_styling()
```

There are lots of printing options: https://haozhu233.github.io/kableExtra/awesome_table_in_html.html

```{r}
head(mazes) %>% 
  kable(format = "html", digits = 2, caption = "A non-full width zebra kable table.") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)
```


```{r}
head(mazes) %>% 
  kable(format = "html", digits = 2, caption = "Over here!") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

## Controlling column appearance

We can control the formatting of individual columns using the `column_spec()` function:

```{r}
head(mazes) %>% 
  kable(format = "html", digits = 2, caption = "Over here!") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>% 
  column_spec(4, width="3cm", background="lightblue", border_right=TRUE)
```

## `kable` + `kableExtra` + `formattable`

`color_tile` and `color_bar` are neat extras if used wisely!

http://haozhu233.github.io/kableExtra/use_kableExtra_with_formattable.html

```{r}
library(formattable)
head(mazes) %>% 
  mutate(ca = color_tile("transparent", "lightpink")(ca),
         viq = color_bar("lightseagreen")(viq)) %>%
  kable("html", escape = F, caption = 'This table is colored.') %>%
  kable_styling(position = "center") %>% 
  column_spec(4, width = "3cm") 
```


## `tibble` + `kable` + `kableExtra`

You can also use any of these tools with plain text tables using the [`tibble` package](http://tibble.tidyverse.org) to create a table. Two main functions:

- `tribble`: enter tibble by rows
- `tibble`: enter tibble by columns


For example, I used `tribble` to make this table in our slide decks:
```{r}
math_table <- tibble::tribble(
  ~Operator, ~Description, ~Usage,
  "\\+", "addition", "x + y",
  "\\-", "subtraction", "x - y",
  "\\*", "multiplication", "x * y",
  "/", "division", "x / y",
  "^", "raised to the power of", "x ^ y",
  "abs", "absolute value", "abs(x)",
  "%/%", "integer division", "x %/% y",
  "%%", "remainder after division", "x %% y"
)
```

Then I used this chunk to print it:

````
```{r, results = 'asis'}`r ''`
knitr::kable(math_table, format = "html", caption = "Helpful mutate functions") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```
````

```{r results = 'asis'}
knitr::kable(math_table, format = "html", caption = "Helpful mutate functions") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

# Markdown Tables

Sometimes you may just want to type in a table in Markdown and ignore R. Four kinds of tables may be used. The first three kinds presuppose the use of a fixed-width font, such as Courier. The fourth kind can be used with proportionally spaced fonts, as it does not require lining up columns. All of the below will render when typed *outside* of an R code chunk since these are based on `pandoc` being used to render your markdown document. Note that these should all work whether you are knitting to either html or PDF.


## Simple table

This code for a simple table:


```{r eval = FALSE}
  Right     Left     Center     Default
-------     ------ ----------   -------
     12     12        12            12
    123     123       123          123
      1     1          1             1

Table:  Demonstration of simple table syntax.
```

Produces this simple table:

  Right     Left     Center     Default
-------     ------ ----------   -------
     12     12        12            12
    123     123       123          123
      1     1          1             1

Table:  Demonstration of simple table syntax.

The headers and table rows must each fit on one line. Column alignments are determined by the position of the header text relative to the dashed line below it:3

* If the dashed line is flush with the header text on the right side but extends beyond it on the left, the column is right-aligned.
* If the dashed line is flush with the header text on the left side but extends beyond it on the right, the column is left-aligned.
* If the dashed line extends beyond the header text on both sides, the column is centered.
* If the dashed line is flush with the header text on both sides, the default alignment is used (in most cases, this will be left).
* The table must end with a blank line, or a line of dashes followed by a blank line.

The column headers may be omitted, provided a dashed line is used to end the table.

## Multi-line tables

This code for a multi-line table:

```{r eval = FALSE}
-------------------------------------------------------------
 Centered   Default           Right Left
  Header    Aligned         Aligned Aligned
----------- ------- --------------- -------------------------
   First    row                12.0 Example of a row that
                                    spans multiple lines.

  Second    row                 5.0 Here's another one. Note
                                    the blank line between
                                    rows.
-------------------------------------------------------------

Table: Here's the caption. It, too, may span
multiple lines.
```

Produces this multi-line table:

-------------------------------------------------------------
 Centered   Default           Right Left
  Header    Aligned         Aligned Aligned
----------- ------- --------------- -------------------------
   First    row                12.0 Example of a row that
                                    spans multiple lines.

  Second    row                 5.0 Here's another one. Note
                                    the blank line between
                                    rows.
-------------------------------------------------------------

Table: Here's the caption. It, too, may span
multiple lines.

## Grid tables

This code for a grid table:

```{r eval = FALSE}
: Sample grid table.

+---------------+---------------+--------------------+
| Fruit         | Price         | Advantages         |
+===============+===============+====================+
| Bananas       | $1.34         | - built-in wrapper |
|               |               | - bright color     |
+---------------+---------------+--------------------+
| Oranges       | $2.10         | - cures scurvy     |
|               |               | - tasty            |
+---------------+---------------+--------------------+
```

Produces this grid table:

: Sample grid table.

+---------------+---------------+--------------------+
| Fruit         | Price         | Advantages         |
+===============+===============+====================+
| Bananas       | $1.34         | - built-in wrapper |
|               |               | - bright color     |
+---------------+---------------+--------------------+
| Oranges       | $2.10         | - cures scurvy     |
|               |               | - tasty            |
+---------------+---------------+--------------------+

Alignments are not supported, nor are cells that span multiple columns or rows. 

## Pipe tables

This code for a pipe table:

```{r eval = FALSE}
| Right | Left | Default | Center |
|------:|:-----|---------|:------:|
|   12  |  12  |    12   |    12  |
|  123  |  123 |   123   |   123  |
|    1  |    1 |     1   |     1  |

  : Demonstration of pipe table syntax.
```

Produces this pipe table:

| Right | Left | Default | Center |
|------:|:-----|---------|:------:|
|   12  |  12  |    12   |    12  |
|  123  |  123 |   123   |   123  |
|    1  |    1 |     1   |     1  |

  : Demonstration of pipe table syntax.


# Making tables in R

If you want to make tables that include R output (like output from functions like means, variances, or output from models), there are two steps: 

1. Get the numbers you need in tabular format; then
2. Render that information in an aesthetically-pleasing way.

This section covers (1). But, although there are some nice options for (2) within R Markdown via various packages, I am not dogmatic about doing *everything* in R Markdown, especially things like (2).

Note that many of the tidying techniques we'll be using are ones we've seen before; you'll be using them in the challenge assignment this week on this dataset, so hopefully this walk-through will give you some ideas.

## `dplyr`

We'll use the `pnwflights14` package to practice our `dplyr` skills. We need to download the package from github using `devtools`.

```{r eval = FALSE}
# once per machine
install.packages("devtools")
devtools::install_github("ismayc/pnwflights14")
```

Now, we need to load the `flights` dataset from the `pnwflights14` package.

```{r eval = FALSE}
# once per work session
data("flights", package = "pnwflights14")
```


### `dplyr::select`

Recall that we use select to specify which columns in a dataframe you'd like to keep **by name**:

```{r use-dplyr-select}
# keep these 2 cols
mini_flights <- flights %>% 
  select(carrier, flight)
glimpse(mini_flights)

# keep first five cols
first_five <- flights %>% 
  select(year, month, day, dep_time, dep_delay)
glimpse(first_five)

# alternatively, specify range
first_five <- flights %>% 
  select(year:dep_delay)
glimpse(first_five)
```

We can also choose the columns we want by negation, that is, you can specify which columns to drop instead of keep. This way, all variables **not** listed are kept.

```{r drop-select}
# we can also use negation
all_but_year <- flights %>% 
  select(-year)
glimpse(all_but_year)
```



`dplyr::select` comes with several other helper functions...


```{r dplyr-select-helpers}
depart <- flights %>%
  select(starts_with("dep_"))
glimpse(depart)

times <- flights %>%
  select(contains("time"))
glimpse(times)

# note that we are not actually saving the new dataframe here
flights %>%
  select(-contains("time")) %>% head()


delays <- flights %>%
  select(ends_with("delay"))
glimpse(delays)
```

One of my favorite select helper functions is `everything()`, which allows you to use select to keep **all** your variables, but easily rearrange the columns without having to list all the variables to keep/drop.

```{r dplyr-select-everything}
new_order <- flights %>% 
  select(origin, dest, everything())
head(new_order)

# with negation
new_order2 <- flights %>% 
  select(origin, dest, everything(), -year)
head(new_order2)
```


We can also rename variables within select.

```{r rename-select}
flights2 <- flights %>%
  select(tail_num = tailnum, everything())
head(flights2)
```

If you don't want to move the renamed variables within your dataframe, you can use the `rename` function.

```{r rename}
flights3 <- flights %>%
  rename(tail_num = tailnum)
glimpse(flights3)
```

### `dplyr::filter`

As we have previously seen, `filter` has many flexible uses:


```{r dplyr-filter}
# flights taking off from PDX
pdx <- flights %>% 
  filter(origin == "PDX")
head(pdx)

# january flights from PDX
pdx_jan <- flights %>% 
  filter(origin == "PDX", month == 1) # the comma is an "and"
head(pdx_jan)

# flights to ATL (Atlanta) or BNA (Nashville)
to_south <- flights %>% 
  filter(dest == "ATL" | dest == "BNA") %>% # | is "or"
  select(origin, dest, everything())
head(to_south)

# flights from PDX to ATL (Atlanta) or BNA (Nashville)
pdx_to_south <- flights %>% 
  filter(origin == "PDX", dest == "ATL" | dest == "BNA") %>% # | is "or"
  select(origin, dest, everything())
head(pdx_to_south)

# alternatively, using group membership
south_dests <- c("ATL", "BNA")
pdx_to_south2 <- flights %>% 
  filter(origin == "PDX", dest %in% south_dests) %>% 
  select(origin, dest, everything())
head(pdx_to_south2)

# flights delayed by 1 hour or more
delay_1plus <- flights %>%
  filter(dep_delay >= 60)
head(delay_1plus)

# flights delayed by 1 hour, but not more than 2 hours
delay_1hr <- flights %>%
  filter(dep_delay >= 60, dep_delay < 120)
head(delay_1hr)
range(delay_1hr$dep_delay, na.rm = TRUE)

# even more efficient using between (always inclusive)
delay_bwn <- flights %>%
  filter(between(dep_delay, 60, 119))
head(delay_bwn)
range(delay_bwn$dep_delay, na.rm = TRUE)
```


### `dplyr::arrange`

```{r}
# default is ascending order
flights %>% 
  arrange(year, month, day) %>% head(n=20)

# descending order
flights %>% 
  arrange(desc(year), desc(month), desc(day)) %>% head(n=20)
```


### `dplyr::distinct`


```{r}
# unique origin-dest combinations
flights %>% 
  select(origin, dest) %>% 
  distinct %>% head(n=50)

# all unique destinations from PDX (there are 49, so we'll just list the first few)
from_pdx <- flights %>% 
  filter(origin == "PDX") %>% 
  select(origin, dest) %>%
  distinct(dest)
head(from_pdx)
```



### `dplyr::mutate`

`mutate` is used to transform existing variables or create new ones; here, we are using it to create an indicator variable that identifies flights that were entirely on-time.

```{r}
# add total delay variable
flights %>%
  mutate(tot_delay = dep_delay + arr_delay) %>%
  select(origin, dest, ends_with("delay"), everything()) %>% 
  head

# flights that were delayed at departure had on time or early arrivals?
arrivals <- flights %>%
  mutate(arr_ok = ifelse(dep_delay > 0 & arr_delay <= 0, 1, 0)) %>% 
  select(origin, dest, ends_with("delay"), carrier, arr_ok)

# peek at it
arrivals %>%
  filter(arr_ok == 1) %>%
  head
```



### `dplyr::summarise` (or `dplyr::summarize`)

We have seen `summarise` used to calculate summary statistics, like so:

```{r}
flights %>%
  summarise(mean(dep_delay, na.rm = TRUE))
```

But this can get tedious when we want to compute several summary statistics, like so:

```{r}
# we can also name that variable, and summarise multiple variables
flights %>%
  summarise(mean_delay = mean(dep_delay, na.rm = TRUE),
            sd_delay = sd(dep_delay, na.rm = TRUE),
            median_delay = median(dep_delay, na.rm = TRUE))
```

`summarise_each` lets us automate this process a bit:


```{r}
flights %>%
  filter(!is.na(dep_delay)) %>%
  select(dep_delay) %>%
  summarise_each(lst(mean, sd, median))

# same thing
flights %>%
  filter(!is.na(dep_delay)) %>%
  summarise_each(lst(mean, sd, median), dep_delay)

# combine with pivot_longer, change names too
flights %>%
  filter(!is.na(dep_delay)) %>%
  summarise_each(lst(mean, stdev = sd, median), dep_delay) %>%
  pivot_longer(everything(), names_to="delay_stat", values_to="value")
```

We can use aggregating functions in `summarise`

```{r}
# how many unique destinations?
summary_table <- flights %>% 
  summarise(tot_flights = n(),
            tot_planes = n_distinct(tailnum),
            tot_carriers = n_distinct(carrier),
            tot_dests = n_distinct(dest),
            tot_origins = n_distinct(origin))

summary_table
```

The resulting table is a bit messy; we can reprocess using `pivot_longer` and `separate`:

```{r}
# chain with tidyr functions
summary_table %>% 
  pivot_longer(everything(), names_to="key", values_to="value") %>% 
  separate(key, into = c("tot", "entity")) %>% 
  select(-tot, total = value)
```
Or we can do it in a single call to `pivot_longer()`:

```{r}
summary_table %>% 
  pivot_longer(
    everything(), # grab all columns
    names_to="entity", # make a new column called "entity" to store the old column names
    names_prefix="tot_", # remove the "tot_" prefix from the old column names
    values_to="total") # put the values in a column called "total"
```


## `tidyr`

We'll work with a made up dataframe:

```{r}
df <- data.frame(
  id = 1:10,
  date = as.Date('2015-01-01') + 0:9,
  q1_m1_w1 = rnorm(10, 0, 1),
  q1_m1_w2 = rnorm(10, 0, 1),
  q1_m2_w3 = rnorm(10, 0, 1),
  q2_m1_w1 = rnorm(10, 0, 1),
  q2_m2_w1 = rnorm(10, 0, 1),
  q2_m2_w2 = rnorm(10, 0, 1)
)
```

```{r}
# HLO
head(df)
glimpse(df)
```

### `tidyr::pivot_longer`

First, let's pivot...
```{r}
df_tidy <- df %>%
  pivot_longer(q1_m1_w1:q2_m2_w2, names_to="key", values_to="value")
head(df_tidy)
```


### `tidyr::separate`

```{r}
# separate 1 col into 3 cols
df_sep <- df_tidy %>%
  separate(key, into = c("quarter", "month", "week"))
head(df_sep)

# separate 1 col into 2 cols
df_sep2 <- df_tidy %>%
  separate(key, into = c("quarter", "period"), extra = "merge")
head(df_sep2)
```
stringr vs. tidyr separate by regular expression

### `tidyr::extract`

`Extract` is essentially the same as `separate`, let's see how...

```{r}
# extract
df_ext <- df_sep2 %>%
  extract(period, into = "month")
head(df_ext)
```

We can see that, by default, it's taking the first alphanumeric chunk of the value, and `extract`ing it. We can specify much more complex patterns: 

```{r}
# this gives us same output as separate
df_ext <- df_sep2 %>%
  extract(period, into = c("month", "week"), 
          regex = "([[:alnum:]]+)_([[:alnum:]]+)")
head(df_ext)
```

### `tidyr::unite`

The `unite()` function lets us reverse the process:

```{r}
# let's say we want to combine quarter and month with an underscore
df_uni <- df_sep %>%
  unite(period, quarter:month) # sep = "_" is the default arg
head(df_uni)

# let's say we want to combine quarter and month with nothing
df_uni <- df_sep %>%
  unite(period, quarter:month, sep = "")
head(df_uni)
```

### `tidyr::pivot_wider`

```{r}
# finally let's spread
df_spread <- df_uni %>%
  pivot_wider(names_from=week, values_from=value)  # fill = NA is default arg
head(df_spread)
```

### Putting it all together (`pivot_longer() %>% separate() %>% pivot_wider()`)

All in one, if we had wanted to end up with one row per month:

```{r}
df_tidiest <- df %>% 
  pivot_longer(q1_m1_w1:q2_m2_w2, names_to="key", values_to="value") %>% 
  separate(key, into = c("quarter", "month", "week")) %>% 
  pivot_wider(names_from=week, values_from=value)
head(df_tidiest)
```

## `broom`

"The broom package takes the messy output of built-in functions in R, such as `lm`, `nls`, or `t.test`, and turns them into tidy data frames." So, broom tidies output from other R functions that are un-tidy.

See here for list of functions: https://github.com/dgrtwo/broom

Vignette: ftp://cran.r-project.org/pub/R/web/packages/broom/vignettes/broom.html

```{r}
fit <- lm(mpg ~ qsec + factor(am) + wt + factor(gear), 
          data = mtcars)
```

Un-tidy output from `lm`
```{r}
summary(fit)
```

Tidy output from `broom`
```{r}
tidy(fit)
```


# Specialized Packages

## `gt`

`gt` is a [relatively new package from RStudio](https://gt.rstudio.com/reference/cols_align.html) designed for publication-ready figures.

<img src="https://gt.rstudio.com/reference/figures/gt_parts_of_a_table.svg"/>

```{r}
library(gt)
```

Let's set up a tiny little data table...

```{r}
prepped_flight_data <- flights %>% filter(dest %in% c("DEN", "DCA", "JFK", "SFO")) %>% 
  group_by(dest) %>% 
  mutate_at(vars(dep_delay), replace_na, replace=0.0) %>%  
  summarise(mean_delay=mean(dep_delay, na.rm=TRUE), median_delay=median(dep_delay, na.rm=TRUE))
glimpse(prepped_flight_data)
```
... and now make a table out of it:
```{r}
gt_formatted <- prepped_flight_data %>%  gt() %>% 
  tab_header(title="PDX Departure Delays, DCA/DEN/JFK/SFO", subtitle="(Delay in minutes)") %>% 
  fmt_number(columns=vars(mean_delay, median_delay), decimals=2) %>% 
  cols_label(dest="Destination", mean_delay="Mean", median_delay="Median") 
gt_formatted 
```

We can adjust things like text alignment after-the-fact:

```{r}
gt_formatted <- gt_formatted %>% 
  cols_align(align="center", columns=vars(dest)) %>%
  tab_style(
    cell_text(align = "right"), 
    locations = cells_title(groups = c("subtitle"))
  ) %>% 
  tab_style(
    cell_text(style = "italic"),
    locations = cells_title(groups=c("title"))
  )
gt_formatted
```

**Tip:** In addition to `cells_title()`, there are helpers to select any of the other cell types (e.g. `cells_column_labels()`, etc.).

Now we can turn it into whatever we need! As Latex:

```{r eval=FALSE}
gt_formatted %>% gtsave("my_table.tex")

```

As RTF, to put in Word:

```{r=FALSE}
gt_formatted %>% gtsave("my_table.rtf")
```

## `tableone`

`tableone` is for generating "Table 1" in your paper. You know, the "Subject Characteristics" table- lots of boring summary statistics.

Vignette: https://cran.r-project.org/web/packages/tableone/vignettes/introduction.html

```{r eval = FALSE}
library(tableone)
```

By default, its output is probably not what we want (though we can see hints of it down at the bottom)...

```{r}
CreateTableOne(data = mazes)
```

We need to tell it a bit about what we are looking for:

```{r}

## Vector of variables to summarize
my_num_vars <- c("ca", "viq", "content", "filler", "rep", "rev", "fs", "cued", "not_cued")

## Vector of categorical variables that need transformation
my_cat_vars <- c("dx", "activity")

## Create a TableOne object
tab2 <- CreateTableOne(vars = my_num_vars, data = mazes, factorVars = my_cat_vars)
print(tab2, showAllLevels = TRUE)
```

If we want the summary statistics to be computed on a per-strata basis, we can ask for that:

```{r}
# Another 
tab3 <- CreateTableOne(vars = my_num_vars, strata = "dx" , data = mazes)
tab3
```
## The `DT` package

`DT` lets us produce interactive data tables for use in HTML reports that go far beyond `kable`'s capabilities.

An excellent tutorial on DT is available at https://rstudio.github.io/DT/.

"Out of the box", `datatable` gives us a very usable table:

```{r}
datatable(mazes)
```



## `pixiedust` (best for PDF)

`Pixiedust` is a ggplot-inspired table package that includes a lot of flexibility and works well for PDF-based output. We can illustrate its use by making a regression table.

Remember that `broom` package we used earlier? Here is what the model parameters look like; this is obviously not what a publicatio-ready version of the table would look like:

```{r}
tidy(fit)
```
Pixiedust gives us many controls for things like column names, row values, formatting for columns, etc.:

```{r}
dust(fit) %>% 
  sprinkle(cols = "term", 
           replace = c("Intercept", "Quarter Mile Time", "Automatic vs. Manual",
                       "Weight", "Gears: 4 vs. 3", "Gears: 5 vs 3")) %>%
  sprinkle(cols = c("estimate", "std.error", "statistic"),
           round = 3) %>% 
  sprinkle(cols = "p.value", fn = quote(pvalString(value))) %>% 
  sprinkle_colnames("Term", "Coefficient", "SE", "T-statistic", "P-value")
```
For more information about Pixiedust, consult:

  - https://cran.r-project.org/web/packages/pixiedust/vignettes/pixiedust.html
  - http://www.suchanutter.net/pixiedust/index.html


# Finally, fonts!

## Your friend, `extrafont`

The [`extrafont` package](https://github.com/wch/extrafont) is the best place to start with fonts in R and ggplot.

```{r}
library(extrafont)
```


Note: Make sure to follow _all_ installation instructions from `github`!

You can access fonts on your local system in `ggplot` by using the `theme()` function to set the relevant properties of your figure.

```{r}
demo_plt <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color=Species)) + 
  geom_point(size=3) +
  scale_color_discrete(labels=c("Setosa", "Versicolor", "Virginica")) + 
  labs(x="Sepal Length (cm)", y="Sepal Width (cm)", title="Fisher's Irises") 
demo_plt
```

In `ggplot`, the `theme()` function lets us control the appearance of various aspects of the plot. There are [many, many properties](https://ggplot2.tidyverse.org/reference/theme.html) we can tweak; we will begin by setting the global `text` property for all text on the entire plot.

Let's try changing that font a bit:

```{r}
demo_plt + theme(text=element_text(family="Optima"))
```

```{r}
demo_plt + theme(text=element_text(family="Palatino"))
```

```{r}
demo_plt + theme(text=element_text(family="Zapfino"))
```

Note that the specific _name_ that you must use to refer to the font is not exactly obvious. It is not the font name, but rather the font's "family name". Because of some under-the-hood details about the way that fonts work, this is a bit different from what you might see in e.g. a font selection menu in Word. You can see a list of all the fonts that R knows about by using the `fonttable()` command:

```{r}
fonttable() %>% glimpse()
```

```{r}
fonttable() %>% head()
```


```{r}
fonttable() %>% select(FullName, FamilyName, FontName) %>% head(20)
```


```{r}
fonttable() %>% select(FamilyName) %>% distinct()
```


Long story short, you'll want to use the value in `FamilyName` to refer to your font of interest.

What if we wanted to have a different font for the title? The `plot.title` property is where we would want to look:

```{r}
demo_plt + theme(
  text=element_text(family="Palatino"),
  plot.title=element_text(family="Zapfino")
  )
```

We can follow this pattern to change anything we like about the text in different parts of the plot:

```{r}
demo_plt + theme(
  text=element_text(family="Palatino"),
  plot.title=element_text(family="Zapfino", size=8, color="blue"),
  axis.title.x = element_text(family="Optima", size=24)
  )
```


## Installing new fonts

This part is a bit beyond the scope of this class, but the upshot is that after you install new fonts in your computer, you should tell `extrafont` about it using the `font_import()` command.

### Caveats

`extrafont` only knows about TrueType fonts (ones whose file ends in `.ttf`). If you have an OpenType font you want to use with R, your best bet probably involves the [`showtext` package](https://cran.rstudio.com/web/packages/showtext/vignettes/introduction.html).